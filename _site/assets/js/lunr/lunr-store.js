var store = [{
        "title": "변수/함수 명명 규칙 (PEP 8)",
        "excerpt":"pep8 쓰는 이유  현업에서는 협업하게 되므로 내 코드를 나보다 남들이 더 많이 읽게 된다.  이 때 어떤 변수가 무엇을 뜻하는지 알아볼 수 없고 가독성이 떨어진다면 코드를 유지보수하기 어려워진다.  PEP 8은 이러한 문제를 해결하기 위해 스타일을 정해놓은 것이다.   변수/함수 명명 규칙 (PEP 8)  피해야 할 이름     소문자 l, 대문자 O, 대문자 I 하나만 변수의 이름으로 쓰는 것은 특정 폰트에서 헷갈릴 수 있기 때문에 권장하지 않는다.   패키지와 모듈의 이름     모듈 이름은 짧아야 하고, ==전부 소문자==여야 한다. 가독성을 위해서라면 밑줄(_)을 써야한다.   패키지 이름도 짧아야 하고, ==전부 소문자==여야 한다. 밑줄은 권장하지 않는다.   함수의 이름     함수의 이름은 ==원칙적으로 소문자==여야 하고, 가독성을 위해 밑줄(_)로 단어를 나눌 수 있다.   간혹 threading.py같이 이미 대/소문자를 혼용하는 경우는 대/소문자를 같이 쓰는 경우도 있다.   클래스 이름     클래스 이름은 ==CapWords 형식==(단어를 대문자로 시작)을 따른다.   exception의 이름     exception은 클래스이므로, class와 동일하게 적용한다.   단, ==맨 뒤는 “Error”로 끝==나야 한다.   전역변수의 이름  (전역 변수는 하나의 모듈 안에서만 쓰인다고 가정)     전역 변수의 이름을 짓는 것은 함수 이름을 짓는 것과 같다.   from M import *과 같이 쓰일 모듈에서는 global이 export 될 것을 방지하기 위해 all 메커니즘이나 ==맨 앞을 밑줄로 시작==해야 한다.   함수와 메소드의 인자     ==메소드 인스턴스에 쓰이는 첫 번째 인자는 무조건 self==여야 한다.   ==클래스 메소드의 첫 번째 인자는 무조건 cls==여야 한다.   예약된 키워드(in 등)와 함수의 인자가 겹치는 경우, 변수 이름 맨 뒤에 밑줄 하나를 붙이는 것으로 대체한다.(ex, class_)   메소드 이름과 인스턴스의 이름     함수 이름과 동일하다.   public이 아닌 메소드나 인스턴스의 이름은 밑줄로 시작한다.   상수의 이름     상수 이름은 전부 대문자와 밑줄로 쓰는 것을 원칙으로 한다.   출처: https://hashcode.co.kr/questions/489/파이썬에서-변수함수-이름을-지을-때-규칙이-있나요   변수명 지어주는 사이트  이렇게 변수명을 짓기 귀찮아서 찾다보니 이런 사이트가 있었다.  https://www.curioustore.com/#!/util/naming   마치며  게임 캐릭터 만들고 닉네임 짓는 것도 어려운데 변수의 이름을 남들이 알아보기 쉽게 작명해야 한다는게 많은 고민을 하게 만드는 일 같다.  기억해야 할 점은 좋은 코드는 가독성이 좋아야 한다는 점인 것 같다.  ","categories": ["Python"],
        "tags": ["Python","PEP8"],
        "url": "/python/pep8/",
        "teaser": null
      },{
        "title": "GitHub Commit 비밀번호를 토큰 방식으로 바꾸는 방법",
        "excerpt":"  갑자기 GitHub Commit 오류?  평소와 똑같이 깃허브 커밋하는데 아래와 같은 오류가 발생했다.  remote: Password authentication is temporarily disabled as part of a brownout. Please use a personal access token instead.   remote: Please see https://github.blog/2020-07-30-token-authentication-requirements-for-api-and-git-operations/ for more information.   The requested URL returned error: 403     그래서 저기 써있는 링크에 들어가 봤더니 2021년 8월 13일 이후부터는 모든 Git 작업에 토큰 혹은 SSH키 인증이 필요하다고 한다.  https://github.blog/2020-07-30-token-authentication-requirements-for-api-and-git-operations/   그래서 어떻게 토큰을 발급받는지 포스팅하려고 한다.   Token 발급받는 방법  1번째  Github 로그인하고 Settings에 들어간다.     2번째  Developer settings 탭을 클릭한다.     3번째  Personal access tokens 탭을 클릭하고, Generate new token 버튼을 클릭한다.     4번째  Note에 토큰 이름, Expiration에 만료기간 설정하고, Select scopes에서 권한을 설정해주면 된다.     5번째  Generate toekn 버튼을 클릭하면 토큰이 발급되는데, 그 코드를 안전한 곳에 복사해서 보관해줘야 한다.     Mac  맥북의 경우 Spotlight 검색에서 Keychain access를 검색해서 github를 검색하고 github.com 인터넷 암호를 제거해준다.   다시 GitHub Commit 시도  이제 다시 git push를 하면    username과 password를 묻는다.  username에는 내 깃허브 username을 똑같이 입력하고,  password에는 내 깃허브 비밀번호가 아니라 아까 발급받은 ghp어쩌구로 시작하는 이상한 토큰을 입력하면 된다.  ","categories": ["Git"],
        "tags": ["Git"],
        "url": "/git/github-password-token/",
        "teaser": null
      },{
        "title": "OpenCV를 이용한 영상처리",
        "excerpt":"나는 자율주행 인공지능을 공부하고 싶다.  자율주행 인공지능은 카메라를 통해 촬영하는 영상을 인식해야하기 때문에 영상을 처리하는 방법을 알고싶었다.   그러던 중 아래 링크를 발견했다.  Read, Write and Display a video using OpenCV |   그래서 위 글을 간략하게 리뷰해보면서 OpenCV를 통한 영상처리에 대해 공부해보려고 한다.   비디오란?   먼저, 비디오란 무엇인가?  비디오는 이미지 시퀀스 즉, 사진들을 연속적으로 나열해서 빠르게 전환시켜 보이게되는 것이다.   여기서 이미지가 얼마나 빨리 전환되는지 측정하는 것은 초당 프레임(FPS)라는 것이다.  FPS가 40이라는 말은 초당 40개의 이미지가 표시된다는 의미이다.   비디오 읽어오기  비디오 파일을 읽기 위한 첫 번째 단계는 VideoCapture 객체를 만드는 것이다.  이 인수는 장치(카메라)의 index가 되거나 비디오 파일의 이름이 될 수 있다.   영상 출처: Puppies Dogs Friendship - Free video on Pixabay  import cv2 import os  default_dir = os.getenv('HOME') video_path = os.path.join(default_dir, 'Puppies.mp4')  # Create a VideoCapture object and read from input file # If the input is the camera, pass 0 instead of the video file name cap =  cv2.VideoCapture(video_path)   비디오 표시하기  VideoCapture 객체가 생성된 후 프레임별로 영상을 표시할 수 있다.  그리고 비디오의 프레임은 단순히 이미지이므로 imshow() 함수를 사용하여 표시할 수 있다.   비디오에서 imshow() 함수 뒤에 waitKey() 함수로 각 프레임을 일시정지한다.  이미지의 경우, waitKey() 함수에 0을 넣지만, 비디오 재생을 위해서는 0보다 큰 숫자를 넣어야 한다.  0은 무한한 시간 동안 일시정지하기 때문이다.  이 숫자는 각 프레임이 표시되기를 원하는 시간(ms)과 같다.   웹켐에서는 1을 사용하는 것이 적절하다고 한다.  왜냐하면 waitKey에서 지연을 1ms로 지정하더라도 디스플레이 프레임 속도가 웹캠의 프레임 속도에 의해 제한되기 때문이다.  # Check if camera opened successfully if (cap.isOpened()== False):     print(“Error opening video stream or file”)  # Read until video is completed while(cap.isOpened()):     # Capture frame-by-frame     ret, frame = cap.read()     if ret == True:     # Display the resulting frame         cv2.imshow(‘Frame’,frame)         # Press Q on keyboard to  exit         if cv2.waitKey(1) &amp; 0xFF == ord(‘q’):             break         # Break the loop         else:             break  # When everything done, release the video capture object cap.release()  # Closes all the frames cv2.destroyAllWindows()   (재생됨)   비디오 작성하기  그 다음 단계는 비디오를 저장하는 것이다.   이미지의 경우 cv2.imwrite()를 사용하기만 하면 된다.  하지만 동영상의 경우 VideoWriter 객체를 만들어야 한다.   먼저, 출력 파일 이름을 지정해야 한다.  그 다음, FourCC 코드와 FPS를 지정해야 한다.  마지막으로 프레임 크기를 지정해야 한다.   FourCC는 비디오 코덱을 지정하는 데 사용되는 4byte 코드다.  사용 가능한 코드 목록은 fourcc.org 에서 찾을 수 있다.   하지만 FourCC의 일부 코드는 시스템에 따라 작동이 되지 않을 수도 있다.  MJPG는 안전한 선택이라고 한다.  # Define the codec and create VideoWriter object.The output is stored in 'outpy.avi' file. # Define the fps to be equal to 10. Also frame size is passed.  out = cv2.VideoWriter('outpy.avi',cv2.VideoWriter_fourcc('M','J','P','G'), 10, (frame_width,frame_height))     마무리  최종적으로 코드를 작성하면 아래와 같다.  import cv2 import os import numpy as np   default_dir = os.getenv('HOME') video_path = os.path.join(default_dir, 'Puppies.mp4')  # Create a VideoCapture object and read from input file # If the input is the camera, pass 0 instead of the video file name cap =  cv2.VideoCapture(video_path)  # Check if camera opened successfully if (cap.isOpened() == False):     print(\"Unable to read camera feed\")   # Default resolutions of the frame are obtained.The default resolutions are system dependent. # We convert the resolutions from float to integer. frame_width = int(cap.get(3)) frame_height = int(cap.get(4))  # Define the codec and create VideoWriter object.The output is stored in ‘outpy.avi’ file. out = cv2.VideoWriter(‘outpy.avi’,cv2.VideoWriter_fourcc(‘M’,’J’,’P’,’G’), 120, (frame_width,frame_height)) while(True):     ret, frame = cap.read()     if ret == True:         # Write the frame into the file ‘output.avi’         out.write(frame)         # Display the resulting frame            cv2.imshow(‘frame’,frame)         # Press Q on keyboard to stop recording         if cv2.waitKey(1) &amp; 0xFF == ord(‘q’):             break         # Break the loop         else:             break   # When everything done, release the video capture and video write objects cap.release() out.release()  # Closes all the frames cv2.destroyAllWindows()   이렇게 비디오를 읽고, 쓰고, 표시하는 방법을 통해서 자율주행과 같은 컴퓨터 비전과 머신러닝 학습에 응용할 수 있을 것이다.  ","categories": ["Python"],
        "tags": ["Python","OpenCV"],
        "url": "/python/opencv-video/",
        "teaser": null
      },{
        "title": "Jupyter Notebook에서 자동완성 기능 사용하기",
        "excerpt":"주피터 노트북에서도 vscode처럼 자동완성 기능을 사용할 수 있다.  이런 기능을 사용할 수 있다는 것을 오늘 처음 알게 되었는데 너무 좋아서 감격스러움에 바로 글을 작성하고 있다.   방법은 너무나도 간단하다.  우선 2가지의 방법이 있다.   방법1  터미널에 아래와 같이 jedi를 삭제해준다.  pip uninstall jedi   방법2  jedi를 삭제하지 않으려면 주피터 노트북에서 아래와 같은 magic command를 입력해준다.  %config Completer.use_jedi = False   사용법1  코드 도중 Tab키로 자동완성할 수 있다.      사용법2  Shift+Tab을 누르면 해당 Docstring을 확인할 수 있다.    ","categories": ["Python"],
        "tags": ["Python","Jupyter"],
        "url": "/python/jupyter-notebook-autocomplete/",
        "teaser": null
      },{
        "title": "Flutter로 앱 만들기 ep1",
        "excerpt":"최근에 취미로 클라이밍을 하고 있는데 괜찮은 커뮤니티 앱이 있다면 참 좋겠다 싶었다.  기다릴 내가 아니었다. 이번 기회에 앱도 만들어 보자라는 생각으로 친구랑 둘이 배워서 만들기로 했다.   일단 목표 출시 기간은 4개월이다.   개발 준비  가장 큰 문제는 내가 앱 개발을 전혀 모른다.  당장 인프런에 코드팩토리님의 강의를 결제해서 지난 3개월 간 공부했다.  함께 만드는 친구는 코딩애플님의 강의를 봤다고 한다.   개발 환경     Android, iOS (Flutter)   Firebase Flutter를 사용하면 안드로이드와 ios 둘 다 된다는 점이 정말 장점인것 같다.  그리고 또 하나의 장점은 Firebase를 사용해서 데이터베이스를 쉽게 이용할 수 있는 점이다.   Git 전략  늘 혼자 개발하다가 협업을 하려니 어떻게 코드를 관리할지부터 정해야 했다.    개발 단계에선 대충 이런 흐름으로 만들기로 했다.  설명하자면 나랑 친구 각자 브런치를 만들고, 만들기로 한 기능을 각 브런치에 push하면 서로 코드를 리뷰한 후에 main에 병합하는 간단한 전략이다.   아래 링크를 참고했다.  우린 Git-flow를 사용하고 있어요 | 우아한형제들 기술블로그   디자인 Figma  Figma를 활용했다.    대충 UI만 디자인했다.  세부 디자인은 나중에 디자이너의 도움을 받을 생각이다.   피그마를 처음 활용해봤는데 생각보다 다루기 쉽더라.     V - 커서   H - 손(화면 움직이기)   T - 텍스트 필드   R - 네모 그리기   P - 펜슬 이 정도 단축키만 외워도 정말 편하다.   앱 주요 기능 정리     회원가입/로그인   프로필   홈 화면   클라이밍 센터 정보   캘린더 일지   프로필 화면   유저 차단/숨김   위와 같이 정리했으며 MVP로 빠르게 출시 먼저 할 생각이라서 몇가지 기능이 빠진 상태로 출시될 수도 있다.   마치며  Flutter가 배우기 쉬운 건지 막상 배워보니 금방 배우고 할만 하더라.  나중엔 인공지능 기능을 API로 만들어서 앱에 넣어보고 싶다.  뭐든 버리는 경험은 없다고 생각한다. 이것 또한 나에게 좋은 경험이 될거라고 생각한다.  ","categories": ["Flutter"],
        "tags": ["Flutter","Git","App","Figma"],
        "url": "/flutter/flutter-app-ep1/",
        "teaser": null
      },{
        "title": "바이낸스(Binance)에서 비트코인(BTC) ohlcv 5분봉 가져오기",
        "excerpt":"나는 평소에 바이낸스 선물 거래를 한다.  그러다 어떤 데이터를 넣고 실험해 보고 싶은 게 생겨서 강화 학습으로 만들어 보려고 한다.   강화 학습 공부도 할 겸.   5분봉으로 선택한 이유  나는 단타 모델로 만들 거라서 5분봉 데이터를 사용하기로 했다.  그렇다고 1분봉으로 하기엔 거래가 너무 자주 일어나서 수수료 때문에 손해를 볼 것 같았다.  바이낸스 시장가 수수료 양아치   문제는 바이낸스에선 최대 1000개의 데이터만 가져올 수 있다.  그래서 지금부터라도 천천히 데이터를 쌓아가 될 것 같다.   5분봉 가져오는 코드  import time import requests import json import csv from datetime import datetime  url = \"https://api.binance.com/api/v3/klines\" interval = \"5m\" symbol = \"BTCUSDT\" limit = 1  # 5분봉 데이터를 하나씩 가져옴  while True:     params = {\"symbol\": symbol, \"interval\": interval, \"limit\": limit}     response = requests.get(url, params=params)      if response.status_code == 200:         data = json.loads(response.content)         with open(\"btc_usdt_ohlcv.csv\", mode=\"a\", newline=\"\") as file:             writer = csv.writer(file)             for item in data:                 timestamp = item[0] / 1000  # 밀리초를 초 단위로 변환                 dt_object = datetime.fromtimestamp(timestamp)                 dt_str = dt_object.strftime(\"%Y-%m-%d %H:%M\")                 open_price = float(item[1])                 high_price = float(item[2])                 low_price = float(item[3])                 close_price = float(item[4])                 volume = float(item[5])                 writer.writerow([dt_str, open_price, high_price, low_price, close_price, volume])     else:         print(\"Error:\", response.status_code)      time.sleep(300)  # 5분 대기  코드는 300초(5분)마다 반복 실행된다.   “https://api.binance.com/api/v3/klines”에서 바이낸스 BTC/USDT 쌍의 5분봉 데이터를 가져온다.  가져온 데이터의 ohlcv 데이터만 btc_usdt_ohlv.csv에 저장한다.   newline 인자를 빈 문자열(““)로 지정하여 csv 파일에 빈 줄을 삽입하지 않도록 한다.   datetime 모듈을 사용하여 timestamp를 datetime 객체로 변환하고, strftime() 메서드를 사용하여 필요한 형식으로 포맷한다.  이 코드에서는 “%Y-%m-%d %H:%M” 형식으로 포맷팅한다. 이 형식은 연도-월-일 시:분으로 표현한다.   마치며  경제적 자유를 꿈꿔본다…  ","categories": ["Python"],
        "tags": ["Python","Crawling","ML","Reinforcement Learning"],
        "url": "/python/binance-btc-data/",
        "teaser": null
      }]
